voir design of networks
voir parcours de graphe
voir design de paragraphe

data structures : 
		-buffers circulaires pour chaque client, 
		-table de hash pour clients references,
		-stack de commandes a traiter
		-(ast pour execution des commandes)
		-table de hash pour channels

daemonization du server
shell du client


3 servers codes / server_services codes / clients

to-do :
 - init servers
 - clients locations configuration
 - parsing messages (circular buffer), stack of commands
 - vider buffer (with "\n\r") and parsing
 - finite-state machine and BNF
 	- connection registration messages

 - layer identification between server-clients, generate user struct
 - minimal clients shell

 - sending messages between two clients

// The End //
write test in Python to check all is great

 - connect server-to-server, check if disconnect (PASS, SERVER)
 - align global state information (SERVER, NICK)
 - passing informations from c2c on different servers (routing algorithms)

// Others Networks Projects

-  channels implementations
-  disconnet and flow infos (PING/PONG)
-  user queries cmd
-  interesting implementation details
-  wildmask et VPN, hostname
-  DNS lookups && TLS security ??
-  operators
-  services

// Real End

 - channels operation

client-server errors, conversation level:
	- envoi partielle ou incomplet
	- mauvaise connection (how to provoke)
	- client deconnecte
	- connection non etablie


2 layers object :
	- obj client

-core servers 
-servers tools
-database

3 layers :
id client
msg passing
channels

local / network infos
